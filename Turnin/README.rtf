{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 **********\
Lab 1\
CS321\
10 Sept, 2020\
Brian Wiggins\
***********\
OVERVIEW:\
\
This program creates a number of cache classes specified by the user and gives some useful stats about them. It can store a considerable amount of data.\
\
INCLUDED FILES:\
\
Test.java - source file\
Cache.java - source file\
README - this file\
\
COMPILING AND RUNNING:\
\
In order to compile this project, navigate to its directory in the terminal and use the command\
\

\f1 $ java *.class
\f0 \
\
which will compile all of the source code need to create caches and test them. To use the program once it is compiled, you can run the code with arguments of your choice in the formats:\
\pard\pardeftab720\partightenfactor0

\f1 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \
$ java Test 1 <cache size> <input textfile name> \
\

\f0 for a single cache system
\f1 \
\

\f0 or\

\f1 \
$ java Test 2 <1st-level cache size> <2nd-level cache size> <input textfile name>\
\

\f0 for a double cache system.\
\
The program reads the input text file word by word, and inserts them into a cache for reference later, removing words as they are referenced less frequently. \
\
PROGRAM DESIGN AND IMPORTANT CONCEPTS: \
\
\pard\pardeftab720\partightenfactor0
\cf2 A cache is a storage in memory. If a data item has a copy in cache, application can read this data item from cache directly. The usage of cache is as follows. Whenever an application requires a data item, it searches the cache first. If it is a cache hit, then the cache returns the data item to the application and the data item will be move to the first position in the cache (we call it the Most Recently Used MRU scheme). On the other hand, if it is a cache miss, then the application needs to read the data item from disk and then the data item from disk will be added to the first position of the cache. Note that if the cache is full, the last entry (oldest one) in the cache will be removed before a new entry can be added. Similarly, whenever an application writes a data item to disk, the system will perform the same write operation to the cache copy of the data item (if any) and then move it to the first position in cache. Note that the write operation is equivalent to a remove operation followed by an add operation.\
\
TESTING:\
\
I wrote my own test class to make sure that it works. My cache class is good, but there is something wrong with the test class that I cannot find. With small numbers of data, the program works fine, but for some reason when I use an encyclopedia as a text input, the numbers for hits or references are always off by 1 or 2. I was not able to fix this problem in the test class. The program can handle bad user input and will catch misnamed or missing files. \
\
DISCUSSION:\
\
The biggest issues with the project was the testing. Writing the test class was not very difficult, but for some reason with huge numbers, I am always off by 1 or 2. I don\'92t believe that this is due to the Cache itself, but simply some overseen bug in the test class. I did go to tutoring for help but I did not have this problem until after I had left the tutoring session, for some reason. One concept that this project really cemented in my mind was that writing cache class was very easy, and I believe that this will continue to be true with other data structures. Testing is going to be that hard part. \
\pard\pardeftab720\partightenfactor0
\cf2 \
\
\

\f1 \
\
\
\
}